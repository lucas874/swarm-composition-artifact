	Swarm protocols are a recently-introduced formalism for specifying and verifying the behaviour of distributed ensembles of machines that interact in a swarm. The machines communicate by emitting events that propagate asynchronously throughout the swarm while adhering to a \emph{local-first} paradigm --- meaning that a machine can make progress even without always-active connections to other machines. A swarm behaves correctly if its machines are \emph{eventually faithful} to a swarm protocol, i.e., if they eventually reach a consensus on a valid execution of the protocol. Previous work presents verification methods to ensure eventual fidelity.
    
	Unfortunately, the existing techniques for designing, implementing, and verifying swarm applications based on swarm protocols are \emph{not compositional}. Consequently, such techniques do not support the modular design and development of large and complex swarm applications as compositions of simpler swarms. They also do not support the reuse of machine implementations and they lead to inefficient verification performance.
	
	The paper introduces novel theory and techniques for the compositional specification and verification of swarm protocols, and for the composition of swarms. It also present a compositional method to ensure that a swarm is eventually faithful to a composition of swarm protocols, allowing the reuse and adaptation of pre-existing machines. The artifact, correspondingly, contains software tools for the compositional design, implementation and verification of swarms together with runnable examples from the paper. Additionally, the artifact contains scripts that run the experiments reported in the paper and generates corresponding figures.  
	
    %In this work we address these issues by presenting novel theory and techniques for the compositional specification and verification of swarm protocols, and for the composition of swarms. We also present a compositional method to ensure that a swarm is eventually faithful to a composition of swarm protocols, allowing the reuse and adaptation of pre-existing machines.

    %These contributions and results are implemented in a companion software artifact.
